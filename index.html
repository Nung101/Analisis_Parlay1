<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <title>Fix Robust: Ambil xG from Understat + Prediksi</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;background:#f7f7f7;padding:18px}
    h2{color:#222}
    input,select,button{padding:8px;margin:6px 0;max-width:650px;width:100%}
    button{background:#1f7bd6;color:#fff;border:0;border-radius:6px;cursor:pointer}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .box{background:#fff;padding:12px;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,0.06);flex:1;min-width:260px}
    pre.log{background:#111;color:#0f0;padding:10px;border-radius:6px;max-height:180px;overflow:auto}
    .hasil{background:#e8fff0;border:1px solid #bfe6c9;padding:12px;border-radius:8px;margin-top:12px}
    canvas{max-width:900px;margin-top:12px}
  </style>
</head>
<body>
  <h2>Ambil xG dari Understat â€” Versi Robust (debug friendly)</h2>

  <label>URL Tim 1 (Understat)</label>
  <input id="url1" value="https://understat.com/team/Arsenal/2025/2026" />
  <label>URL Tim 2 (Understat)</label>
  <input id="url2" value="https://understat.com/team/Chelsea/2025/2026" />
  <label>Jumlah match terakhir</label>
  <select id="jumlah">
    <option value="5">5</option>
    <option value="10" selected>10</option>
    <option value="15">15</option>
    <option value="all">Semua</option>
  </select>
  <button onclick="runAll()">Ambil & Prediksi (Robust)</button>

  <div class="row" style="margin-top:14px">
    <div class="box">
      <h3>Output Tim 1</h3>
      <div id="out1">â€”</div>
    </div>
    <div class="box">
      <h3>Output Tim 2</h3>
      <div id="out2">â€”</div>
    </div>
  </div>

  <div class="hasil" id="final">Hasil akan muncul di sini.</div>

  <canvas id="chart" height="120"></canvas>

  <h4>Debug log (console friendly)</h4>
  <pre class="log" id="log">Klik "Ambil & Prediksi" â€” log akan muncul di sini.</pre>

<script>
/* ======================
   Helper: append to on-page log + console
   ====================== */
function log(msg){
  const el = document.getElementById('log');
  const t = new Date().toLocaleTimeString();
  el.textContent = `${t} â€” ${msg}\n` + el.textContent;
  console.log(msg);
}

/* ======================
   Try multiple proxy endpoints to avoid CORS issues.
   Returns HTML text or throws.
   ====================== */
async function fetchHtmlWithProxies(url){
  const proxies = [
    {name:'allorigins', prefix: 'https://api.allorigins.win/get?url=' , type:'json_contents'}, 
    {name:'allorigins_raw', prefix: 'https://api.allorigins.win/raw?url=' , type:'raw'},
    {name:'thingproxy', prefix: 'https://thingproxy.freeboard.io/fetch/' , type:'raw'},
    // last fallback: try direct (may fail due to CORS)
    {name:'direct', prefix: '', type:'raw'}
  ];

  for(const p of proxies){
    try{
      log(`Coba fetch via proxy: ${p.name}`);
      const full = p.prefix + encodeURIComponent(url);
      let resp;
      if(p.type === 'json_contents'){
        resp = await fetch(full, {cache:'no-store'});
        if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const j = await resp.json();
        if(!j || typeof j.contents !== 'string') throw new Error('Proxy tidak mengembalikan contents');
        log(`Proxy ${p.name} sukses (json contents)`);
        return j.contents;
      } else {
        // raw text
        const target = p.prefix ? full : url;
        resp = await fetch(target, {cache:'no-store'});
        if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const text = await resp.text();
        log(`Proxy ${p.name} sukses (raw)`);
        return text;
      }
    }catch(err){
      log(`Proxy ${p.name} gagal: ${String(err)}`);
      // try next proxy
      continue;
    }
  }
  throw new Error('Semua proxy gagal mengambil HTML (CORS / network). Cek koneksi / coba backend.');
}

/* ======================
   Parse Understat HTML robustly â€” try several patterns.
   Returns parsed JS object (the big JSON embedded) or null.
   ====================== */
function parseEmbeddedJsonFromUnderstat(html){
  // 1) Try __NEXT_DATA__ (Next.js) script
  try{
    const r1 = /<script[^>]*id="__NEXT_DATA__"[^>]*>([\s\S]*?)<\/script>/i;
    const m1 = html.match(r1);
    if(m1 && m1[1]){
      log('Menemukan __NEXT_DATA__ JSON');
      return JSON.parse(m1[1]);
    }
  }catch(e){
    log('Gagal parse __NEXT_DATA__: ' + e);
  }

  // 2) Try JSON.parse('...(escaped)') pattern (Understat often uses JSON.parse('...'))
  try{
    // This looks for JSON.parse('...') occurrences. Grab the largest candidate.
    const r2 = /JSON\.parse\('([\s\S]*?)'\)/g;
    let last = null, m;
    while((m = r2.exec(html))!==null){
      last = m[1];
    }
    if(last){
      log('Menemukan JSON.parse(...) block â€” mencoba unescape');
      // Unescape common sequences
      let s = last;
      // Replace escaped single-quotes first, then escaped double-quotes/backslashes/newlines
      s = s.replace(/\\n/g, "\\n");
      s = s.replace(/\\'/g, "'");
      s = s.replace(/\\"/g, '"');
      s = s.replace(/\\\\/g, "\\");
      // now try parse
      return JSON.parse(s);
    }
  }catch(e){
    log('Gagal parse JSON.parse block: ' + e);
  }

  // 3) Try window.__INITIAL_STATE__ = {...}
  try{
    const r3 = /window\.__INITIAL_STATE__\s*=\s*({[\s\S]*?});/i;
    const m3 = html.match(r3);
    if(m3 && m3[1]){
      log('Menemukan window.__INITIAL_STATE__');
      return JSON.parse(m3[1]);
    }
  }catch(e){
    log('Gagal parse INITIAL_STATE: ' + e);
  }

  // 4) fallback: try to find any big JSON object inside <script> tags â€” last resort
  try{
    const scripts = html.match(/<script[^>]*>[\s\S]*?<\/script>/gi) || [];
    for(let i = scripts.length-1; i >= 0; i--){
      const s = scripts[i];
      // find first JSON object-like substring
      const jmatch = s.match(/({[\s\S]{200,}?)<\/script>/);
      if(jmatch && jmatch[1]){
        try {
          const candidate = jmatch[1];
          const o = JSON.parse(candidate);
          log('Berhasil parse fallback script -> JSON');
          return o;
        } catch(e){}
      }
    }
  }catch(e){ /* ignore */ }

  return null;
}

/* ======================
   Find history array & team name inside parsed JSON object
   Returns {teamName, historyArray} or throws
   ====================== */
function extractHistoryAndTeam(parsed){
  // 1) Common Next.js structure: parsed.props.pageProps.data
  try{
    if(parsed && parsed.props && parsed.props.pageProps && parsed.props.pageProps.data){
      const d = parsed.props.pageProps.data;
      // team name in several places
      const teamName = d.title || (d.id && d.id.title) || d.team || d.name || null;
      // history possible keys
      const hist = d.history || d.matches || d.results || d.fixtures || d;
      if(Array.isArray(d.history) && d.history.length>0) return {teamName: teamName || null, history: d.history};
      // if d has .history inside deeper
      if(Array.isArray(d.matches) && d.matches.length>0) return {teamName, history: d.matches};
    }
  }catch(e){ /* ignore */ }

  // 2) Try to find any property named 'history' anywhere (DFS)
  const stack = [parsed];
  while(stack.length){
    const obj = stack.pop();
    if(!obj || typeof obj !== 'object') continue;
    for(const k of Object.keys(obj)){
      try{
        const v = obj[k];
        if(k && k.toLowerCase && k.toLowerCase().includes('history') && Array.isArray(v) && v.length>0){
          return { teamName: (obj.title || obj.name || (obj.id && obj.id.title) || null), history: v };
        }
        // direct history-like array where entries have xG/xGA or 'h'/'a'
        if(Array.isArray(v) && v.length>0){
          const sample = v[0];
          if(sample && (sample.xG || sample.xGA || sample.h || sample.a || sample.hh)) {
            // assume this is history array
            return { teamName: (obj.title || obj.name || (obj.id && obj.id.title) || null), history: v };
          }
        }
        if(typeof v === 'object') stack.push(v);
      }catch(_){} // skip weird properties
    }
  }

  // 3) Try top-level keys that look like team data
  const topCandidates = ['team','teamData','data','initialState'];
  for(const k of topCandidates){
    if(parsed[k] && Array.isArray(parsed[k].history) && parsed[k].history.length>0){
      return { teamName: parsed[k].title || parsed[k].name || null, history: parsed[k].history };
    }
  }

  throw new Error('Tidak menemukan array "history" dalam data yang di-parse. Struktur halaman mungkin berbeda.');
}

/* ======================
   Normalize history entries to a consistent shape
   Each entry -> {hName, aName, xgHome, xgAway, teamXG, teamXGA}
   This supports both "team perspective" entries (m.xG / m.xGA)
   and full-match entries with m.xG.h, m.xG.a
   ====================== */
function normalizeHistory(history, teamName){
  const out = [];
  for(const m of history){
    let hName = null, aName = null, xgHome = null, xgAway = null, teamXG = null, teamXGA = null;

    // home/away team names (many variants)
    if(m.h && m.h.title) hName = m.h.title;
    else if(m.h && m.h.team) hName = m.h.team;
    else if(m.home) hName = m.home;
    else if(m.h_team) hName = m.h_team;

    if(m.a && m.a.title) aName = m.a.title;
    else if(m.a && m.a.team) aName = m.a.team;
    else if(m.away) aName = m.away;
    else if(m.a_team) aName = m.a_team;

    // Case A: match has m.xG as object with h & a (full match)
    if(m.xG && typeof m.xG === 'object' && (m.xG.h !== undefined || m.xG.a !== undefined)){
      xgHome = parseFloat(m.xG.h || m.xG.home || m.xG[Object.keys(m.xG)[0]] || 0) || 0;
      xgAway = parseFloat(m.xG.a || m.xG.away || 0) || 0;
      // team perspective
      if(teamName && hName === teamName){ teamXG = xgHome; teamXGA = xgAway; }
      else if(teamName && aName === teamName){ teamXG = xgAway; teamXGA = xgHome; }
      else { teamXG = null; teamXGA = null; }
    }
    // Case B: team page style: m.xG (string/number) = team xG, m.xGA = opponent xG
    else if(m.xG !== undefined && (typeof m.xG === 'string' || typeof m.xG === 'number')){
      // some entries use 'xG' & 'xGA' for team-perspective
      teamXG = parseFloat(m.xG) || 0;
      teamXGA = (m.xGA!==undefined) ? (parseFloat(m.xGA)||0) : null;
      // if we have home/away names, try compute xgHome/xgAway using team perspective
      if(hName && aName){
        if(hName === teamName){ xgHome = teamXG; xgAway = teamXGA; }
        else if(aName === teamName){ xgAway = teamXG; xgHome = teamXGA; }
      }
    }
    // Case C: some pages provide m.xG_h and m.xG_a
    else if(m.xG_h !== undefined || m.xG_a !== undefined){
      xgHome = parseFloat(m.xG_h || 0);
      xgAway = parseFloat(m.xG_a || 0);
      if(teamName && hName === teamName){ teamXG = xgHome; teamXGA = xgAway; }
      else if(teamName && aName === teamName){ teamXG = xgAway; teamXGA = xgHome; }
    }

    out.push({
      raw: m,
      hName, aName,
      xgHome, xgAway,
      teamXG, teamXGA
    });
  }
  return out;
}

/* ======================
   Compute averages for a team from normalized history
   Uses teamXG/teamXGA if available in entries; else tries infer from xgHome/xgAway using teamName
   ====================== */
function computeAveragesFromNormalized(normHistory, teamName, jumlah){
  const entries = (jumlah === 'all') ? normHistory : normHistory.slice(-jumlah);
  let sumXG = 0, sumXGA = 0, cnt = 0;
  for(const e of entries){
    if(e.teamXG !== null && e.teamXG !== undefined){
      sumXG += Number(e.teamXG);
      sumXGA += (e.teamXGA !== null && e.teamXGA !== undefined) ? Number(e.teamXGA) : 0;
      cnt++;
    } else {
      // try infer based on home/away
      if(e.hName && e.aName && e.xgHome !== null && e.xgAway !== null){
        if(e.hName === teamName){
          sumXG += Number(e.xgHome); sumXGA += Number(e.xgAway); cnt++;
        } else if(e.aName === teamName){
          sumXG += Number(e.xgAway); sumXGA += Number(e.xgHome); cnt++;
        }
      }
    }
  }
  if(cnt === 0) throw new Error('Tidak dapat hitung avg xG/xGA: format history tidak dikenali.');
  return { avgXG: sumXG / cnt, avgXGA: sumXGA / cnt, usedMatches: cnt };
}

/* ======================
   Prediction helpers (same logic as sebelumnya)
   ====================== */
function predictScores(avg1, avgGA1, avg2, avgGA2){
  // simple approach: predicted goals for team1 = (avg1 + avgGA2)/2 (as used before)
  const p1 = (avg1 + avgGA2) / 2;
  const p2 = (avg2 + avgGA1) / 2;
  return {p1, p2, total: p1 + p2};
}
function ouLabelAndConfidence(total){
  if(total < 2.5){
    const conf = Math.min(95, Math.round((2.5 - total) * 40 + 50));
    return {label:'Under 2.5', conf};
  } else if(total < 3.5){
    const conf = Math.round(60 + (Math.abs(total - 3.0) * 20));
    return {label:'Over 2.5 (tapi Under 3.5)', conf};
  } else {
    const conf = Math.min(95, Math.round((total - 3.5) * 30 + 60));
    return {label:'Over 3.5', conf};
  }
}
function hdpLabelAndConfidence(p1, p2, name1, name2){
  const diff = Math.abs(p1 - p2);
  const conf = Math.min(95, Math.round(diff * 40 + 50));
  if(diff < 0.25) return {label:'Pick/Draw Handicap (imbang)', conf:50};
  if(p1 > p2) return {label: `${name1} -0.25 / -0.5`, conf};
  return {label: `${name2} -0.25 / -0.5`, conf};
}

/* ======================
   main runner: fetch -> parse -> extract -> normalize -> compute -> show
   ====================== */
let globalChart = null;
async function runAll(){
  const url1 = document.getElementById('url1').value.trim();
  const url2 = document.getElementById('url2').value.trim();
  let jumlah = document.getElementById('jumlah').value;
  jumlah = (jumlah === 'all') ? 'all' : parseInt(jumlah);

  // clear UI
  document.getElementById('out1').innerHTML = 'loading...';
  document.getElementById('out2').innerHTML = 'loading...';
  document.getElementById('final').innerHTML = 'Processing...';
  log(`Mulai proses. url1=${url1} url2=${url2} jumlah=${jumlah}`);

  try{
    const html1 = await fetchHtmlWithProxies(url1);
    const html2 = await fetchHtmlWithProxies(url2);

    // parse embedded JSON
    const parsed1 = parseEmbeddedJsonFromUnderstat(html1);
    const parsed2 = parseEmbeddedJsonFromUnderstat(html2);
    if(!parsed1) throw new Error('Gagal parse data tim1 (parsed1 null). Lihat log.');
    if(!parsed2) throw new Error('Gagal parse data tim2 (parsed2 null). Lihat log.');

    log('JSON embedded berhasil di-parse untuk kedua tim.');

    // extract history & team name
    const e1 = extractHistoryAndTeam(parsed1);
    const e2 = extractHistoryAndTeam(parsed2);

    log(`e1.team=${e1.teamName} historyLen=${e1.history.length}  | e2.team=${e2.teamName} historyLen=${e2.history.length}`);

    // normalize histories
    const norm1 = normalizeHistory(e1.history, e1.teamName);
    const norm2 = normalizeHistory(e2.history, e2.teamName);

    // compute averages
    const avg1 = computeAveragesFromNormalized(norm1, e1.teamName, jumlah);
    const avg2 = computeAveragesFromNormalized(norm2, e2.teamName, jumlah);

    log(`avg1.avgXG=${avg1.avgXG.toFixed(3)} avg1.avgXGA=${avg1.avgXGA.toFixed(3)} (used ${avg1.usedMatches})`);
    log(`avg2.avgXG=${avg2.avgXG.toFixed(3)} avg2.avgXGA=${avg2.avgXGA.toFixed(3)} (used ${avg2.usedMatches})`);

    // predict
    const pred = predictScores(avg1.avgXG, avg1.avgXGA, avg2.avgXG, avg2.avgXGA);
    const ou = ouLabelAndConfidence(pred.total);
    const hdp = hdpLabelAndConfidence(pred.p1, pred.p2, e1.teamName || 'Tim1', e2.teamName || 'Tim2');

    // populate UI
    document.getElementById('out1').innerHTML = `<b>${e1.teamName || 'Team 1'}</b><br>
      Avg xG (for): ${avg1.avgXG.toFixed(2)}<br>Avg xGA: ${avg1.avgXGA.toFixed(2)}<br>matches used: ${avg1.usedMatches}`;
    document.getElementById('out2').innerHTML = `<b>${e2.teamName || 'Team 2'}</b><br>
      Avg xG (for): ${avg2.avgXG.toFixed(2)}<br>Avg xGA: ${avg2.avgXGA.toFixed(2)}<br>matches used: ${avg2.usedMatches}`;

    document.getElementById('final').innerHTML = `
      <h3>ðŸ“ˆ Hasil Prediksi (robust)</h3>
      Prediksi skor (rounded): <b>${e1.teamName || 'Team1'} ${Math.round(pred.p1)} - ${Math.round(pred.p2)} ${e2.teamName || 'Team2'}</b><br>
      Total expected gol: <b>${pred.total.toFixed(2)}</b><br><br>
      Over/Under rekomendasi: <b>${ou.label}</b> (Confidence: ${ou.conf}%)<br>
      Handicap rekomendasi: <b>${hdp.label}</b> (Confidence: ${hdp.conf}%)
    `;

    // draw chart: avg xG vs avg xGA
    const ctx = document.getElementById('chart').getContext('2d');
    if(globalChart) globalChart.destroy();
    globalChart = new Chart(ctx, {
      type:'bar',
      data:{
        labels: [e1.teamName || 'T1', e2.teamName || 'T2'],
        datasets:[
          {label:'Avg xG (for)', data:[avg1.avgXG, avg2.avgXG], backgroundColor:'rgba(54,162,235,0.7)'},
          {label:'Avg xGA (against)', data:[avg1.avgXGA, avg2.avgXGA], backgroundColor:'rgba(255,99,132,0.7)'}
        ]
      },
      options:{
        responsive:true,
        plugins:{title:{display:true,text:'Perbandingan Avg xG & xGA'}} ,
        scales:{y:{beginAtZero:true}}
      }
    });

    log('Selesai proses. Lihat hasil di bagian atas.');

  }catch(err){
    const message = (err && err.message) ? err.message : String(err);
    log('ERROR utama: ' + message);
    document.getElementById('final').innerHTML = `<b>ERROR:</b> ${message}. <br>Jika masih error: buka Console (F12) dan kirim pesan error ke saya.`;
    console.error(err);
  }
}
</script>
</body>
</html>